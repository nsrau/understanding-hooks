(this["webpackJsonpunderstanding-hooks"]=this["webpackJsonpunderstanding-hooks"]||[]).push([[0],{17:function(e,t,n){e.exports=n(28)},22:function(e,t,n){},28:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),l=n(15),o=n.n(l),c=n(9),u=n(1),m=n(7);var i=Object(a.memo)((function(e){var t=e.item;return r.a.createElement("li",null,r.a.createElement("strong",null,t.title)," ",r.a.createElement("i",null,t.body))}));var s=Object(a.memo)((function(){var e=Object(a.useState)([]),t=Object(m.a)(e,2),n=t[0],l=t[1],o=Object(a.useState)(""),c=Object(m.a)(o,2),u=c[0],s=c[1];return Object(a.useEffect)((function(){fetch("https://jsonplaceholder.typicode.com/posts").then((function(e){return e.json()})).then((function(e){return l(e)}))}),[]),r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"React.memo is a higher order component. If your component renders the same result given the same props, you can wrap it in a call to React.memo for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result. React.memo only checks for prop changes. If your function component wrapped in React.memo has a useState or useContext Hook in its implementation, it will still rerender when state or context change."),r.a.createElement("hr",null),r.a.createElement("input",{placeholder:"search",value:u,onChange:function(e){return s(e.target.value)}}),r.a.createElement("ul",null,n.map((function(e){return r.a.createElement(i,{key:e.id,item:e})}))))}));function d(){var e=Object(a.useState)(0),t=Object(m.a)(e,2),n=t[0],l=t[1],o=Object(a.useState)(0),c=Object(m.a)(o,2),u=c[0],i=c[1],s=Object(a.useMemo)((function(){for(var e=0;e<999999999;)e++;return n%2===0}),[n]);return r.a.createElement("div",null,r.a.createElement("p",null,"Returns a memoized value. Pass a \u201ccreate\u201d function and an array of dependencies. useMemo will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render. Remember that the function passed to useMemo runs during rendering. Don\u2019t do anything there that you wouldn\u2019t normally do while rendering. For example, side effects belong in useEffect, not useMemo. If no array is provided, a new value will be computed on every render."),r.a.createElement("hr",null),r.a.createElement("button",{onClick:function(){l(n+1)}},"counter slow - ",n)," ",s?"Even":"Odd",r.a.createElement("hr",null),r.a.createElement("button",{onClick:function(){i(u+1)}},"counter - ",u))}n(22);function h(){return r.a.createElement(c.b,{basename:"/"},r.a.createElement(c.a,null,r.a.createElement(r.a.Fragment,null,r.a.createElement("nav",{className:"menu"},r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(c.c,{to:"/memo"},"memo")),r.a.createElement("li",null,r.a.createElement(c.c,{to:"/useMemo"},"useMemo")))),r.a.createElement("div",{className:"content"},r.a.createElement(u.c,null,r.a.createElement(u.a,{path:"/memo"},r.a.createElement(s,null)),r.a.createElement(u.a,{path:"/useMemo"},r.a.createElement(d,null)),r.a.createElement(u.a,{path:"/"},r.a.createElement("p",null,"use react profiler")))))))}o.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(h,null)),document.getElementById("root"))}},[[17,1,2]]]);
//# sourceMappingURL=main.a9d085ee.chunk.js.map